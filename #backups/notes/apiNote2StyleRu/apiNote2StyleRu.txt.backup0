// 2021-07-06 14:05:38

// полный if
if (cond) {
	// code
} 
else {
	// code
}

if (cond)
	// code
else
	// code

// частичный if
if (cond) {
	// code
} 

// if else if
if (cond) {
	// code
}
else
if (cond) {
	// code
}
...

// однострочный и другие однострочники
if (cond) // code
if (cond)
	// code
while (cond) // code
while (cond)
	// code
repeat const // code
repeat const
	// code
repeat (expr) // code
repeat (expt)
	// code
for (..;..;..) // code
for (..;..;..) 
	// code

//
while (cond) {
	// code
}

//
do {
	// code
} until (cond)

//
for (..;..;..) {
	// code
}

//
repeat const {
	// code
}
repeat (expr) {
	// code
}

// допускается миксование (||, &&, ^^) и (and, or, xor)
// and, or, xor являются ленивыми операциями

// тернарный оператор обязан быть взят в скобки
(a ? b : c) - так же является ленивым оператором

// вложенные тернарные операторы не рекомендуются

// функции объявляются только в файлах скриптов на самом верхнем уровне, в иных случаях использоватся должны методы
function thisName

//
with (all) - запрещено

// 
var ar = [0, 1, 2];
var ar = [
	0,
	1,
];

var struct = {name: "hello", mark: true};
var struct = {
	name: "hello",
	mark: true
};

// return
return const;
return (expr);

// точка с запятой очень сильно рекомендуется.

// сахарный доступ
array = [1, 2];
value = array[i];   // get
array[@ i] = value; // set

// запрещено использовать особенность массивов - псевдо-типаж copy 
var array = [1, 2];
var array2 = array;
array[0] = array[0]; // в данном случаи произойдёт клонирование массива с глубинной вложености 1

// other
struct[$ key]
grid[# xkey, ykey]
map[? key]

// запрещенно, так как компилятор не гарантирует сохранения порядка вычислений при вызовах функций (ощутимо на разных платформах)
call(i++, i++, f(), f());
var array = [i++, i++, f(), f()]; // сахар над функцией
var struct = {k0: i++, k1: i++, k2: f(), k3: f()}; // сахар над функцией

- функция f требует объяснений, но их не будет. Опытные пользователи и так поймут в чём тут дело, а именно в том, что нет гарантии сохранения порядка вычислений
- если функция f чистая, то конечно её можно тут применить

в api настоятельно не рекомендуется использовать рекурсию (пока не добавят хвостовую оптимизацию - тоесть никогда)
к тому же любой (возможно нет) алгоритм можно выразить через цикл

пожалуйста не делайте DSL в большом количестве
